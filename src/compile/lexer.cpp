#include <compile/lexer.hpp>

std::vector<Token> lex(char srcFilePath[])
{
    std::ifstream file(srcFilePath);
    std::string src(std::istreambuf_iterator<char>{file}, {});
    Lexer lexer(src);
    std::vector<Token> tokens = lexer.tokenize();
    std::printf("src: %s\n", src.c_str());
    std::println("Tokens Generated by Lexical Analyzer:");
    printTokens(tokens);
    return tokens;
}

std::vector<Token> Lexer::tokenize()
{
    char tmp1[4];
    std::string tmp2;
    bool tmp3;
    std::vector<Token> tokens;
    while(this->position < this->input.length())
    {
        char currentChar = this->input[this->position];

        if(this->isWhitespace(currentChar))
        {
            this->position++;
            continue;
        }
        if(isAlpha(currentChar))
        {
            std::string word = this->getNextWord();
            if(this->keywords.find(word) != this->keywords.end())
                tokens.emplace_back(TokenType::KEYWORD, word);
            else if(this->types.find(word) != this->types.end())
                tokens.emplace_back(TokenType::TYPE, word);
            else
                tokens.emplace_back(TokenType::IDENTIFIER, word);
        }
        else if(isDigit(currentChar))
        {
            Number number = getNextNumber();
            if(number.isFloat)
                tokens.emplace_back(TokenType::FLOAT, number.value);
            else if(number.isDouble)
                tokens.emplace_back(TokenType::DOUBLE, number.value);
            else if(number.isHex)
                tokens.emplace_back(TokenType::HEX_INTEGER, number.value);
            else if(number.isBin)
                tokens.emplace_back(TokenType::BIN_INTEGER, number.value);
            else
                tokens.emplace_back(TokenType::INTEGER, number.value);
            
        }
        else if(currentChar == '+' || currentChar == '-' || currentChar == '*' || currentChar == '/' || currentChar == '^' || currentChar == '|' || currentChar == '!' || currentChar == '&')
            tokens.emplace_back(TokenType::OPERATOR, std::string(1, currentChar));
        else if(currentChar == '(' || currentChar == ')' || currentChar == '[' || currentChar == ']' || currentChar == '{' || currentChar == '}' || currentChar == ';' || currentChar == ':' || currentChar == ',')
            tokens.emplace_back(TokenType::PUNCTUATOR, std::string(1, currentChar));
        else if(currentChar == '\'')
        {
            this->position++;
            tmp1[0] = this->input[this->position];
            if(tmp1[0] == '\\')
            {
                this->position++;
                tmp1[1] = this->input[this->position];
                tmp3 = true;
            }
            this->position++;
            tmp1[2] = this->input[this->position];
            if(tmp1[2] == '\'' && !tmp3)
            {
                tokens.emplace_back(TokenType::CHARACTER, std::string(1, tmp1[1]));
                tmp3 = false;
                strcpy(tmp1, "");
            }
            else if(tmp1[3] == '\'' && tmp3)
            {
                tokens.emplace_back(TokenType::CHARACTER, std::string(2, tmp1[1] + tmp1[2]));
                tmp3 = false;
                strcpy(tmp1, "");
            }
            else
            {
                break;
            }
        }
        else if(currentChar == '\"')
        {
            position++;
            for(; this->input[this->position] != '\"'; this->position++)
            {
                tmp2.append(std::string(1, this->input[this->position]));
                if(this->input[this->position] == '\\')
                {
                    this->position++;
                    tmp2.append(std::string(1, this->input[this->position]));
                }
            }
            tokens.emplace_back(TokenType::STRING, tmp2);
            tmp2.clear();
        }
        else
            tokens.emplace_back(TokenType::UNKNOWN, std::string(1, currentChar));
    }
    return tokens;
}

Number::Number(std::string value, bool isDouble, bool isFloat, bool isHex, bool isBin)
{
    this->value = value;
    this->isDouble = isDouble;
    this->isFloat = isFloat;
    this->isHex = isHex;
    this->isBin = isBin;
}

Number Lexer::getNextNumber()
{
    size_t start = this->position;
    bool hasDecimal = false;
    bool isFloat = false;
    bool isDouble = false;
    bool isHex = false;
    bool isBin = false;
    while(this->position < this->input.length() && (isDigit(this->input[this->position]) || this->input[this->position] == '.' || this->input[this->position] == 'f' || this->input[this->position] == 'd'))
    {
        if(this->input[this->position] == '.')
        {
            if(hasDecimal)
                break;
            hasDecimal = true;
        }
        else if(this->input[this->position] == '%')
        {
            isBin = true;
        }
        else if(this->input[this->position] == '#')
        {
            isHex = true;
        }
        else if(hasDecimal && !isBin && !isHex)
        {
            if(isAlpha(this->input[this->position]))
            {
                if(this->input[this->position] == 'f')
                    isFloat = true;
                else if(this->input[this->position] == 'd')
                    isDouble = true;
                else
                    break;
            }
        }
        else if(isFloat || isDouble)
            break;

        this->position++;
    }
    return Number(input.substr(start, position - start), isDouble, isFloat, isHex, isBin);
}

std::string Lexer::getNextWord()
{
    size_t start = this->position;
    while(this->position < this->input.length() && this->isAlphaNumeric(this->input[position]))
    {
        this->position++;
    }
    return this->input.substr(start, this->position - start);
}

bool Lexer::isAlphaNumeric(char c)
{
    return this->isAlpha(c) || this->isDigit(c);
}

bool Lexer::isDigit(char c)
{
    return c >= '0' && c <= '9';
}

bool Lexer::isAlpha(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

bool Lexer::isWhitespace(char c)
{
    return c == ' ' || c == '\t' || c == '\n' || '\r';
}

void Lexer::initKeywords()
{
    this->keywords["entry"] = TokenType::KEYWORD;
    this->keywords["var"] = TokenType::KEYWORD;
    this->keywords["func"] = TokenType::KEYWORD;
    this->keywords["unsigned"] = TokenType::KEYWORD;
    this->keywords["if"] = TokenType::KEYWORD;
    this->keywords["else"] = TokenType::KEYWORD;
    this->keywords["elif"] = TokenType::KEYWORD;
    this->keywords["for"] = TokenType::KEYWORD;
    this->keywords["while"] = TokenType::KEYWORD;
    this->keywords["do"] = TokenType::KEYWORD;
    this->keywords["switch"] = TokenType::KEYWORD;
    this->keywords["try"] = TokenType::KEYWORD;
    this->keywords["throw"] = TokenType::KEYWORD;
    this->keywords["catch"] = TokenType::KEYWORD;
    this->keywords["break"] = TokenType::KEYWORD;
    this->keywords["continue"] = TokenType::KEYWORD;
    this->keywords["return"] = TokenType::KEYWORD;
    this->keywords["exit"] = TokenType::KEYWORD;
}

void Lexer::initTypes()
{
    this->types["int"] = TokenType::TYPE;
    this->types["byte"] = TokenType::TYPE;
    this->types["short"] = TokenType::TYPE;
    this->types["long"] = TokenType::TYPE;
    this->types["float"] = TokenType::TYPE;
    this->types["double"] = TokenType::TYPE;
    this->types["char"] = TokenType::TYPE;
    this->types["string"] = TokenType::TYPE;
    this->types["void"] = TokenType::TYPE;
}

std::string getTokenTypeName(TokenType type)
{
    switch(type)
    {
        case TokenType::KEYWORD:
            return "KEYWORD";
        case TokenType::IDENTIFIER:
            return "IDENTIFIER";
        case TokenType::STRING:
            return "STRING";
        case TokenType::OPERATOR:
            return "OPERATOR";
        case TokenType::INTEGER:
            return "INTEGER";
        case TokenType::BIN_INTEGER:
            return "BIN_INTEGER";
        case TokenType::HEX_INTEGER:
            return "HEX_INTEGER";
        case TokenType::FLOAT:
            return "FLOAT";
        case TokenType::DOUBLE:
            return "DOUBLE";
        case TokenType::TYPE:
            return "TYPE";
        case TokenType::CHARACTER:
            return "CHARACTER";
        case TokenType::PUNCTUATOR:
            return "PUNCTUATOR";
        case TokenType::UNKNOWN:
            return "UNKNOWN";
        default:
            return "UNDEFINED";
    }
}

void printTokens(const std::vector<Token>& tokens)
{
    for(const auto& token : tokens)
    {
        std::printf("Type: %s, Value: %s\n", getTokenTypeName(token.type).c_str(), token.value.c_str());
    }
}
