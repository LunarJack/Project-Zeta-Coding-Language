#include <compile/lexer.hpp>

void printTokens(const std::vector<Token>& tokens);

std::vector<Token> lex(char srcFilePath[])
{
    std::ifstream file(srcFilePath);
    std::string src(std::istreambuf_iterator<char>{file}, {});
    Lexer lexer(src);
    std::vector<Token> tokens = lexer.tokenize();
    std::printf("src: %s\n", src.c_str());
    std::println("Tokens Generated by Lexical Analyzer:");
    printTokens(tokens);
    return tokens;
}

std::vector<Token> Lexer::tokenize()
{
    char tmp1[4];
    std::string tmp2;
    bool tmp3;
    std::vector<Token> tokens;
    char currentChar;
    try
    {
        while(position < input.length())
        {
            currentChar = input[position];

            if(isWhitespace(currentChar))
            {
                position++;
                continue;
            }
            if(isAlpha(currentChar))
            {
                std::string word = getNextWord();
                if(keywords.find(word) != keywords.end())
                    tokens.emplace_back(TokenType::KEYWORD, word);
                else if(types.find(word) != types.end())
                    tokens.emplace_back(TokenType::TYPE, word);
                else
                    tokens.emplace_back(TokenType::IDENTIFIER, word);
            }
            else if(isDigit(currentChar))
            {
                Number number = getNextNumber();
                if(number.isFloat)
                    tokens.emplace_back(TokenType::FLOAT, number.value);
                else if(number.isDouble)
                    tokens.emplace_back(TokenType::DOUBLE, number.value);
                else if(number.isHex)
                    tokens.emplace_back(TokenType::HEX_INTEGER, number.value);
                else if(number.isBin)
                    tokens.emplace_back(TokenType::BIN_INTEGER, number.value);
                else
                    tokens.emplace_back(TokenType::INTEGER, number.value);
            
            }
            else if(currentChar == '+' || currentChar == '-' || currentChar == '*' || currentChar == '/' || currentChar == '^' || currentChar == '|' || currentChar == '!' || currentChar == '&')
                tokens.emplace_back(TokenType::OPERATOR, std::string(1, currentChar));
            else if(currentChar == '(' || currentChar == ')' || currentChar == '[' || currentChar == ']' || currentChar == '{' || currentChar == '}' || currentChar == ';' || currentChar == ':' || currentChar == ',')
                tokens.emplace_back(TokenType::PUNCTUATOR, std::string(1, currentChar));
            else if(currentChar == '\'')
            {
                position++;
                tmp1[0] = input[position];
                if(tmp1[0] == '\\')
                {
                    position++;
                    tmp1[1] = input[position];
                    tmp3 = true;
                }
                position++;
                tmp1[2] = input[position];
                if(tmp1[2] == '\'' && !tmp3)
                {
                    tokens.emplace_back(TokenType::CHARACTER, std::string(1, tmp1[1]));
                    tmp3 = false;
                    strcpy(tmp1, "");
                }
                else if(tmp1[3] == '\'' && tmp3)
                {
                    tokens.emplace_back(TokenType::CHARACTER, std::string(2, tmp1[1] + tmp1[2]));
                    tmp3 = false;
                    strcpy(tmp1, "");
                }
                else
                {
                    throw(001);
                }
            }
            else if(currentChar == '\"')
            {
                position++;
                for(; input[position] != '\"'; position++)
                {
                    tmp2.append(std::string(1, input[position]));
                    if(input[position] == '\\')
                    {
                        position++;
                        tmp2.append(std::string(1, input[position]));
                    }
                }
                tokens.emplace_back(TokenType::STRING, tmp2);
                tmp2.clear();
            }
            else
                tokens.emplace_back(TokenType::UNKNOWN, std::string(1, currentChar));
        }
    }
    catch(int errorCode)
    {
        std::fprintf(stderr, "Error, error code: %d", errorCode);
        exit(1);
    }
    return tokens;
}

Number::Number(std::string value, bool isDouble, bool isFloat, bool isHex, bool isBin)
{
    this->value = value;
    this->isDouble = isDouble;
    this->isFloat = isFloat;
    this->isHex = isHex;
    this->isBin = isBin;
}

Number Lexer::getNextNumber()
{
    size_t start = position;
    bool hasDecimal = false;
    bool isFloat = false;
    bool isDouble = false;
    bool isHex = false;
    bool isBin = false;
    while(position < input.length() && (isDigit(input[position]) || input[position] == '.' || input[position] == 'f' || input[position] == 'd' || input[position] == '%' || input[position] == '#') && input[position] != ';')
    {
        if(input[position] == '.')
        {
            if(hasDecimal)
                break;
            hasDecimal = true;
        }
        else if(input[position] == '%')
        {
            isBin = true;
        }
        else if(input[position] == '#')
        {
            isHex = true;
        }
        else if(hasDecimal && !isBin && !isHex)
        {
            if(isAlpha(input[position]))
            {
                if(input[position] == 'f')
                    isFloat = true;
                else if(input[position] == 'd')
                    isDouble = true;
                else
                    break;
            }
        }
        else if(isFloat || isDouble)
            break;

        position++;
    }
    return Number(input.substr(start, position - start), isDouble, isFloat, isHex, isBin);
}

std::string Lexer::getNextWord()
{
    size_t start = position;
    while(position < input.length() && isAlphaNumeric(input[position]))
    {
        position++;
    }
    return input.substr(start, position - start);
}

bool Lexer::isAlphaNumeric(char c)
{
    return isAlpha(c) || isDigit(c);
}

bool Lexer::isDigit(char c)
{
    return c >= '0' && c <= '9';
}

bool Lexer::isAlpha(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

bool Lexer::isWhitespace(char c)
{
    return c == ' ' || c == '\t' || c == '\n' || '\r';
}

void Lexer::initKeywords()
{
    keywords["entry"] = TokenType::KEYWORD;
    keywords["var"] = TokenType::KEYWORD;
    keywords["par"] = TokenType::KEYWORD;
    keywords["func"] = TokenType::KEYWORD;
    keywords["unsigned"] = TokenType::KEYWORD;
    keywords["if"] = TokenType::KEYWORD;
    keywords["else"] = TokenType::KEYWORD;
    keywords["elif"] = TokenType::KEYWORD;
    keywords["for"] = TokenType::KEYWORD;
    keywords["while"] = TokenType::KEYWORD;
    keywords["do"] = TokenType::KEYWORD;
    keywords["switch"] = TokenType::KEYWORD;
    keywords["try"] = TokenType::KEYWORD;
    keywords["throw"] = TokenType::KEYWORD;
    keywords["catch"] = TokenType::KEYWORD;
    keywords["break"] = TokenType::KEYWORD;
    keywords["continue"] = TokenType::KEYWORD;
    keywords["return"] = TokenType::KEYWORD;
    keywords["exit"] = TokenType::KEYWORD;
}

void Lexer::initTypes()
{
    types["int"] = TokenType::TYPE;
    types["byte"] = TokenType::TYPE;
    types["short"] = TokenType::TYPE;
    types["long"] = TokenType::TYPE;
    types["float"] = TokenType::TYPE;
    types["double"] = TokenType::TYPE;
    types["char"] = TokenType::TYPE;
    types["string"] = TokenType::TYPE;
    types["void"] = TokenType::TYPE;
}

std::string getTokenTypeName(TokenType type)
{
    switch(type)
    {
        case TokenType::KEYWORD:
            return "KEYWORD";
        case TokenType::IDENTIFIER:
            return "IDENTIFIER";
        case TokenType::STRING:
            return "STRING";
        case TokenType::OPERATOR:
            return "OPERATOR";
        case TokenType::INTEGER:
            return "INTEGER";
        case TokenType::BIN_INTEGER:
            return "BIN_INTEGER";
        case TokenType::HEX_INTEGER:
            return "HEX_INTEGER";
        case TokenType::FLOAT:
            return "FLOAT";
        case TokenType::DOUBLE:
            return "DOUBLE";
        case TokenType::TYPE:
            return "TYPE";
        case TokenType::CHARACTER:
            return "CHARACTER";
        case TokenType::PUNCTUATOR:
            return "PUNCTUATOR";
        case TokenType::UNKNOWN:
            return "UNKNOWN";
        default:
            return "UNDEFINED";
    }
}

void printTokens(const std::vector<Token>& tokens)
{
    for(const auto& token : tokens)
    {
        std::printf("Type: %s, Value: %s\n", getTokenTypeName(token.type).c_str(), token.value.c_str());
    }
}